#include "Protheus.ch"

#define CRLF    CHR(13)+CHR(10)
#define LF      CHR(10)

/*=====================================================================
|---------------------------------------------------------------------|
| Programa | ARAPIFUN | Autor: Andres Demarziani | Fecha: 03/02/2020  |
|---------------------------------------------------------------------|
| Descripcion: Clase con funciones comunes para APIs REST             |
|---------------------------------------------------------------------|
| Cliente: DESAB                                                      |
|---------------------------------------------------------------------|
======================================================================*/
CLASS ARAPIFUN
	
    STATIC METHOD fInitVars()
    STATIC METHOD fIniciaAmbiente()
    STATIC METHOD fMountErrorJson()
    STATIC METHOD fEscapeJson()
    STATIC METHOD fCierraAmbiente()
    STATIC METHOD Str2Array()
    STATIC METHOD GetRootPath()
    STATIC METHOD SQLParser()

END CLASS

/*=====================================================================
|----------------------------------------------------------------------
| Programa | fInitVars | Autor: Andres Demarziani
|----------------------------------------------------------------------
| Descripcion: Inicializa variables comunes
|----------------------------------------------------------------------
======================================================================*/
METHOD fInitVars(lTest, jPath, cBody, cEmp, cSuc, cCodApi, cBodyTest, cApiTest) CLASS ARAPIFUN

    If lTest
        cBody     := cBodyTest
        cCodApi   := cApiTest
    Else
        jPath     := oRest:getPathParamsRequest()
        cBody     := oRest:getBodyRequest()
        cEmp      := jPath["emp"]
        cSuc      := jPath["suc"]
        cCodApi   := jPath["codigo-api"]
    EndIf

Return Nil

/*=====================================================================
|----------------------------------------------------------------------
| Programa | fIniciaAmbiente | Autor: Andres Demarziani
|----------------------------------------------------------------------
| Descripcion: Inicia el ambiente de ejecución
|----------------------------------------------------------------------
======================================================================*/
METHOD fIniciaAmbiente(lTest, cEmp, cSuc, cCodApi) CLASS ARAPIFUN

    Local aUserProtheus := U_ArApiProtheusUser()
    Local oError

    If !lTest
        RpcSetType(3)
        If !RpcSetEnv(cEmp, cSuc, aUserProtheus[1], aUserProtheus[2], "FAT")
            oError := ErrorClass():New()            
            oError:genCode := 150126
            oError:description := "Usuario/Contraseña Protheus inválido."

            THROW oError
        EndIf
    EndIf

    cCodApi := PadR(cCodApi, TamSX3("ZJ1_CODIGO")[1])

Return Nil

/*=====================================================================
|----------------------------------------------------------------------
| Programa | fCierraAmbiente | Autor: Andres Demarziani
|----------------------------------------------------------------------
| Descripcion: Cierra el ambiente de ejecución
|----------------------------------------------------------------------
======================================================================*/
METHOD fCierraAmbiente(lTest) CLASS ARAPIFUN

    If !lTest
        // RpcClearEnv()
    EndIf
    
Return Nil

/*=====================================================================
|----------------------------------------------------------------------
| Programa | fMountErrorJson | Autor: Andres Demarziani
|----------------------------------------------------------------------
| Descripcion: Funcion para armar el JSON de errores
|----------------------------------------------------------------------
======================================================================*/
METHOD fMountErrorJson(aErrores) CLASS ARAPIFUN

    Local cJson := '{ "error": "VALIDACION", "detalles": [' 
    Local nI

    For nI := 1 To Len(aErrores)
        If nI > 1
            cJson += ", "
        EndIf
        cJson += '"'+ARAPIFUN():fEscapeJson(aErrores[nI])+'"'
    Next

    cJson += "] }"

Return cJson

/*=====================================================================
|----------------------------------------------------------------------
| Programa | fEscapeJson | Autor: Andres Demarziani
|----------------------------------------------------------------------
| Descripcion: Escapa texto para que sea seguro dentro de un JSON.
|              Maneja:
|               - Comillas dobles
|               - Backslash
|               - CR / LF
|               - TAB
|               - Backspace / FormFeed
|               - Caracteres de control ASCII (0..31)
======================================================================*/
METHOD fEscapeJson(cText) CLASS ARAPIFUN

    Local cRet  := ""
    Local nPos
    Local cChar
    Local nAsc
    Local cBS   := Chr(92)   // "\"

    If cText == Nil
        Return ""
    EndIf

    // Aseguro string
    If ValType(cText) != "C"
        cText := cValToChar(cText)
    EndIf

    For nPos := 1 To Len(cText)

        cChar := SubStr(cText, nPos, 1)
        nAsc  := Asc(cChar)

        Do Case
        // JSON mandatory escapes
        Case cChar == '"'
            cRet += cBS + '"'

        Case cChar == cBS
            cRet += cBS + cBS

        // Control characters comunes
        Case cChar == Chr(10)      // LF
            cRet += cBS + "n"

        Case cChar == Chr(13)      // CR
            cRet += cBS + "r"

        Case cChar == Chr(9)       // TAB
            cRet += cBS + "t"

        Case cChar == Chr(8)       // Backspace
            cRet += cBS + "b"

        Case cChar == Chr(12)      // Form feed
            cRet += cBS + "f"

        // Cualquier otro control ASCII (0..31)
        Case nAsc >= 0 .And. nAsc < 32
            cRet += " "

        Otherwise
            cRet += cChar
        EndCase
    Next nPos

Return cRet

/*=====================================================================
|----------------------------------------------------------------------
| Programa | Str2Array | Autor: Andres Demarziani
|----------------------------------------------------------------------
| Descripcion: Convierte una cadena separada por cSep en un array
|----------------------------------------------------------------------
======================================================================*/
METHOD Str2Array(cString, cSep) CLASS ARAPIFUN

    Local aReturn := { },;
        cAux    := cString,;
        nPos    := 0

    While At( cSep, cAux ) > 0
    nPos := At( cSep, cAux )
        Aadd( aReturn, SubStr( cAux, 1, nPos-1 ) )
        cAux := SubStr( cAux, nPos+1 )
    End

    Aadd(aReturn, cAux)

Return aReturn

/*=====================================================================
|----------------------------------------------------------------------
| Programa | fGetRootPath | Autor: Andres Demarziani
|----------------------------------------------------------------------
| Descripcion: Obtiene el root path del servidor HTTP configurado
|----------------------------------------------------------------------
======================================================================*/
METHOD GetRootPath() CLASS ARAPIFUN

    Local cAppSrv       := GetAdv97()
    Local cServers      := AllTrim(GetPvProfString("HTTPSERVER", "Servers", "", cAppSrv))
    Local nIndexComma   := At(",", cServers) 
    Local cServer       := If(nIndexComma > 0, AllTrim(SubStr(cServers, 1, nIndexComma-1)), cServers)
    Local cLocation     := ""
    Local cRootPath     := "/"

    If !Empty(cServer)
        cLocation := AllTrim(GetPvProfString(cServer, "Locations", "", cAppSrv))

        If !Empty(cLocation)
            cRootPath := AllTrim(GetPvProfString(cLocation, "Path", "/", cAppSrv))
        EndIf
    EndIf

    If !Right(cRootPath,1) $ "/"
        cRootPath += "/"
    EndIf

Return cRootPath

/*=====================================================================
|----------------------------------------------------------------------
| Programa | SQLParser | Autor: Andres Demarziani
|----------------------------------------------------------------------
| Descripcion: Formatea una cadena SQL para su uso en el programa
|----------------------------------------------------------------------
======================================================================*/
METHOD SQLParser(cSql) CLASS ARAPIFUN

Local aStrSql	:= {}
Local cLinSql	:= ''
Local cNewSql	:= ''
Local cRet		:= ''
Local nS		:= 1

If Empty(cSql)
	Return cRet
EndIf

If ( "UPDATE"$cSql .Or. "TRUNCATE"$cSql .Or. "INSERT"$cSql .Or. "DELETE"$cSql )
	MsgStop("No esta permitido ejecutar sentencias de actualización de base de datos (UPDATE, TRUNCATE, DELETE, INSERT).", "Verifique")
	Return cRet
EndIf

aStrSql	:= ARAPIFUN():Str2Array(cSql,CRLF)	

For nS := 1 To Len(aStrSql)
    cLinSql	:= StrTran(aStrSql[nS],'"',"'")
    cLinSql	:= StrTran(cLinSql,CRLF," ")
    cLinSql	:= StrTran(cLinSql,LF," ")
    cLinSql	:= '"'+cLinSql+'"'
    cLinSql	:= StrTran(cLinSql,"[",'"+')
    cLinSql	:= StrTran(cLinSql,"]",'+"')
    
    cNewSql	+= &(cLinSql)+CRLF
Next nS	

cRet := cNewSql

Return cRet
